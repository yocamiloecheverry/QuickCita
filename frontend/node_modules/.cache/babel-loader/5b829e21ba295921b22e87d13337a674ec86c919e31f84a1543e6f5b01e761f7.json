{"ast":null,"code":"import { Transport } from \"../transport.js\";\nimport { randomString } from \"../util.js\";\nimport { encodePayload, decodePayload } from \"engine.io-parser\";\nexport class Polling extends Transport {\n  constructor() {\n    super(...arguments);\n    this._polling = false;\n  }\n  get name() {\n    return \"polling\";\n  }\n  /**\r\n   * Opens the socket (triggers polling). We write a PING message to determine\r\n   * when the transport is open.\r\n   *\r\n   * @protected\r\n   */\n  doOpen() {\n    this._poll();\n  }\n  /**\r\n   * Pauses polling.\r\n   *\r\n   * @param {Function} onPause - callback upon buffers are flushed and transport is paused\r\n   * @package\r\n   */\n  pause(onPause) {\n    this.readyState = \"pausing\";\n    const pause = () => {\n      this.readyState = \"paused\";\n      onPause();\n    };\n    if (this._polling || !this.writable) {\n      let total = 0;\n      if (this._polling) {\n        total++;\n        this.once(\"pollComplete\", function () {\n          --total || pause();\n        });\n      }\n      if (!this.writable) {\n        total++;\n        this.once(\"drain\", function () {\n          --total || pause();\n        });\n      }\n    } else {\n      pause();\n    }\n  }\n  /**\r\n   * Starts polling cycle.\r\n   *\r\n   * @private\r\n   */\n  _poll() {\n    this._polling = true;\n    this.doPoll();\n    this.emitReserved(\"poll\");\n  }\n  /**\r\n   * Overloads onData to detect payloads.\r\n   *\r\n   * @protected\r\n   */\n  onData(data) {\n    const callback = packet => {\n      // if its the first message we consider the transport open\n      if (\"opening\" === this.readyState && packet.type === \"open\") {\n        this.onOpen();\n      }\n      // if its a close packet, we close the ongoing requests\n      if (\"close\" === packet.type) {\n        this.onClose({\n          description: \"transport closed by the server\"\n        });\n        return false;\n      }\n      // otherwise bypass onData and handle the message\n      this.onPacket(packet);\n    };\n    // decode payload\n    decodePayload(data, this.socket.binaryType).forEach(callback);\n    // if an event did not trigger closing\n    if (\"closed\" !== this.readyState) {\n      // if we got data we're not polling\n      this._polling = false;\n      this.emitReserved(\"pollComplete\");\n      if (\"open\" === this.readyState) {\n        this._poll();\n      } else {}\n    }\n  }\n  /**\r\n   * For polling, send a close packet.\r\n   *\r\n   * @protected\r\n   */\n  doClose() {\n    const close = () => {\n      this.write([{\n        type: \"close\"\n      }]);\n    };\n    if (\"open\" === this.readyState) {\n      close();\n    } else {\n      // in case we're trying to close while\n      // handshaking is in progress (GH-164)\n      this.once(\"open\", close);\n    }\n  }\n  /**\r\n   * Writes a packets payload.\r\n   *\r\n   * @param {Array} packets - data packets\r\n   * @protected\r\n   */\n  write(packets) {\n    this.writable = false;\n    encodePayload(packets, data => {\n      this.doWrite(data, () => {\n        this.writable = true;\n        this.emitReserved(\"drain\");\n      });\n    });\n  }\n  /**\r\n   * Generates uri for connection.\r\n   *\r\n   * @private\r\n   */\n  uri() {\n    const schema = this.opts.secure ? \"https\" : \"http\";\n    const query = this.query || {};\n    // cache busting is forced\n    if (false !== this.opts.timestampRequests) {\n      query[this.opts.timestampParam] = randomString();\n    }\n    if (!this.supportsBinary && !query.sid) {\n      query.b64 = 1;\n    }\n    return this.createUri(schema, query);\n  }\n}","map":{"version":3,"names":["Transport","randomString","encodePayload","decodePayload","Polling","constructor","arguments","_polling","name","doOpen","_poll","pause","onPause","readyState","writable","total","once","doPoll","emitReserved","onData","data","callback","packet","type","onOpen","onClose","description","onPacket","socket","binaryType","forEach","doClose","close","write","packets","doWrite","uri","schema","opts","secure","query","timestampRequests","timestampParam","supportsBinary","sid","b64","createUri"],"sources":["C:/Users/dae01/Documents/Universidad/QuickCita/frontend/node_modules/engine.io-client/build/esm/transports/polling.js"],"sourcesContent":["import { Transport } from \"../transport.js\";\r\nimport { randomString } from \"../util.js\";\r\nimport { encodePayload, decodePayload } from \"engine.io-parser\";\r\nexport class Polling extends Transport {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._polling = false;\r\n    }\r\n    get name() {\r\n        return \"polling\";\r\n    }\r\n    /**\r\n     * Opens the socket (triggers polling). We write a PING message to determine\r\n     * when the transport is open.\r\n     *\r\n     * @protected\r\n     */\r\n    doOpen() {\r\n        this._poll();\r\n    }\r\n    /**\r\n     * Pauses polling.\r\n     *\r\n     * @param {Function} onPause - callback upon buffers are flushed and transport is paused\r\n     * @package\r\n     */\r\n    pause(onPause) {\r\n        this.readyState = \"pausing\";\r\n        const pause = () => {\r\n            this.readyState = \"paused\";\r\n            onPause();\r\n        };\r\n        if (this._polling || !this.writable) {\r\n            let total = 0;\r\n            if (this._polling) {\r\n                total++;\r\n                this.once(\"pollComplete\", function () {\r\n                    --total || pause();\r\n                });\r\n            }\r\n            if (!this.writable) {\r\n                total++;\r\n                this.once(\"drain\", function () {\r\n                    --total || pause();\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            pause();\r\n        }\r\n    }\r\n    /**\r\n     * Starts polling cycle.\r\n     *\r\n     * @private\r\n     */\r\n    _poll() {\r\n        this._polling = true;\r\n        this.doPoll();\r\n        this.emitReserved(\"poll\");\r\n    }\r\n    /**\r\n     * Overloads onData to detect payloads.\r\n     *\r\n     * @protected\r\n     */\r\n    onData(data) {\r\n        const callback = (packet) => {\r\n            // if its the first message we consider the transport open\r\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\r\n                this.onOpen();\r\n            }\r\n            // if its a close packet, we close the ongoing requests\r\n            if (\"close\" === packet.type) {\r\n                this.onClose({ description: \"transport closed by the server\" });\r\n                return false;\r\n            }\r\n            // otherwise bypass onData and handle the message\r\n            this.onPacket(packet);\r\n        };\r\n        // decode payload\r\n        decodePayload(data, this.socket.binaryType).forEach(callback);\r\n        // if an event did not trigger closing\r\n        if (\"closed\" !== this.readyState) {\r\n            // if we got data we're not polling\r\n            this._polling = false;\r\n            this.emitReserved(\"pollComplete\");\r\n            if (\"open\" === this.readyState) {\r\n                this._poll();\r\n            }\r\n            else {\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * For polling, send a close packet.\r\n     *\r\n     * @protected\r\n     */\r\n    doClose() {\r\n        const close = () => {\r\n            this.write([{ type: \"close\" }]);\r\n        };\r\n        if (\"open\" === this.readyState) {\r\n            close();\r\n        }\r\n        else {\r\n            // in case we're trying to close while\r\n            // handshaking is in progress (GH-164)\r\n            this.once(\"open\", close);\r\n        }\r\n    }\r\n    /**\r\n     * Writes a packets payload.\r\n     *\r\n     * @param {Array} packets - data packets\r\n     * @protected\r\n     */\r\n    write(packets) {\r\n        this.writable = false;\r\n        encodePayload(packets, (data) => {\r\n            this.doWrite(data, () => {\r\n                this.writable = true;\r\n                this.emitReserved(\"drain\");\r\n            });\r\n        });\r\n    }\r\n    /**\r\n     * Generates uri for connection.\r\n     *\r\n     * @private\r\n     */\r\n    uri() {\r\n        const schema = this.opts.secure ? \"https\" : \"http\";\r\n        const query = this.query || {};\r\n        // cache busting is forced\r\n        if (false !== this.opts.timestampRequests) {\r\n            query[this.opts.timestampParam] = randomString();\r\n        }\r\n        if (!this.supportsBinary && !query.sid) {\r\n            query.b64 = 1;\r\n        }\r\n        return this.createUri(schema, query);\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}